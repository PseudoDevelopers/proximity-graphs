
// File link: https://labs.minutelabs.io/toolkit/js/vector.js

///////////////////////////////////////////
// MinuteLabs.io Vector Library
// author: Jasper Palfree (info@minutelabs.io)
// For educational use.
// Copyright 2020 Jasper Palfree
// License: GPLv3
///////////////////////////////////////////

function _drawArrow(ctx, x, y, length, angle, color) {
    ctx.strokeStyle = color
    ctx.fillStyle = color
    ctx.lineWidth = 2
    ctx.translate(x, y)
    ctx.rotate(angle)
    ctx.beginPath()
    ctx.moveTo(0, 0)
    ctx.lineTo(length, 0)
    ctx.stroke()
    ctx.lineTo(length - 6, 6)
    ctx.lineTo(length - 6, -6)
    ctx.lineTo(length, 0)
    ctx.fill()
    ctx.rotate(-angle)
    ctx.translate(-x, -y)
}

class Vector {
    constructor(x = 0, y = 0) {
        this.set(x, y)
    }

    clone() {
        return new Vector(this.x, this.y)
    }

    // set this vector to have the values of another vector
    copy(v) {
        return this.set(v.x, v.y)
    }

    set(x, y) {
        this.x = x
        this.y = y
        return this
    }

    add(other) {
        this.x += other.x
        this.y += other.y
        return this
    }

    plus(other) {
        return this.clone().add(other)
    }

    subtract(other) {
        this.x -= other.x
        this.y -= other.y
        return this
    }

    minus(other) {
        return this.clone().subtract(other)
    }

    multiply(number) {
        this.x *= number
        this.y *= number
        return this
    }

    times(number) {
        return this.clone().multiply(number)
    }

    divide(number) {
        this.x /= number
        this.y /= number
        return this
    }

    dividedBy(number) {
        return this.clone().divide(number)
    }

    normSq() {
        return this.x * this.x + this.y * this.y
    }

    norm() {
        return Math.sqrt(this.normSq())
    }

    setNorm(n) {
        let norm = this.norm()
        if (norm === 0) {
            norm = 1
            this.x = 1
            this.y = 0
        }
        n /= norm
        this.x *= n
        this.y *= n
        return this
    }

    normalize() {
        return this.setNorm(1)
    }

    angle() {
        return Math.atan2(this.y, this.x)
    }

    setAngle(angle) {
        let n = this.norm()
        if (n === 0) {
            n = 1
            this.x = 1
            this.y = 0
        }
        this.x = n * Math.cos(angle)
        this.y = n * Math.sin(angle)
        return this
    }

    rotateBy(angle) {
        return this.setAngle(this.angle() + angle)
    }

    dot(vector) {
        return this.x * vector.x + this.y * vector.y
    }

    proj(vector) {
        let other = vector.clone().normalize()
        return other.multiply(this.dot(other))
    }

    projScalar(vector) {
        return this.dot(vector) / vector.norm()
    }

    clampedProj(vector) {
        let n = vector.norm()
        let other = vector.clone().normalize()
        return other.multiply(Math.min(n, Math.max(0, this.dot(other))))
    }

    clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x))
        this.y = Math.max(min.y, Math.min(max.y, this.y))
        return this
    }

    // perform a reflection with specified normal vector to the mirror
    reflect(normal) {
        let n = normal.normSq()
        return this.subtract(normal.times(2 * this.dot(normal) / n))
    }

    // return a new vector that is the reflection along normal
    reflection(normal) {
        return this.copy().reflect(normal)
    }

    randomize(n = 1) {
        return this.setNorm(n).setAngle(2 * Math.PI * Math.random())
    }

    // Draws this vector to a canvas context
    debugDraw(ctx, offset = null, scale = 1, withComponents = false, color = 'white') {
        let angle = this.angle()
        let n = scale * this.norm()
        let ox = offset ? offset.x : 0
        let oy = offset ? offset.y : 0
        if (withComponents) {
            // _drawArrow(ctx, ox, oy + this.y * scale, scale * this.x, 0, 'red')
            // _drawArrow(ctx, ox, oy, scale * this.y, Math.PI / 2, 'yellow')
            ctx.strokeStyle = 'tomato'
            ctx.translate(ox, oy)
            ctx.beginPath()
            let y = scale * this.y
            ctx.moveTo(0, y)
            ctx.lineTo(scale * this.x, y)
            ctx.stroke()
            ctx.strokeStyle = 'gold'
            ctx.beginPath()
            ctx.moveTo(0, 0)
            ctx.lineTo(0, y)
            ctx.stroke()
            ctx.translate(-ox, -oy)
        }
        _drawArrow(ctx, ox, oy, n, angle, color)
    }
}

function V(x, y) {
    return new Vector(x, y)
}
function lerp(min, max, val) {
    return min + (max - min) * val
}

function rescale(min, max, val) {
    return (val - min) / (max - min)
}

const G = 6.67408e-11   // Gravitational Constant


// Calculate the acceleration of object
// Due to gravitational force of other object
function acceleration(massOfOtherNode, displacement) {
    let distance = displacement.norm()

    const dv = displacement.normalize()
    dv.multiply((G * massOfOtherNode) / (distance * distance))

    return dv
}

function createNode({ mass = 1e1, position = V(0, 0), velocity = V(0, 0) }) {
    return {
        mass: mass,
        radius: 20,
        position: position,
        velocity: velocity,
        color: 'crimson',
        move(Δt) {
            // Position = Initial position + v * Δt
            this.position.add(this.velocity.times(Δt))
        },
        draw() {
            drawCircle(this.position.x, this.position.y, this.radius, this.color)
        },
        chkEdgeBounce() {
            if/***/ (this.position.x >= width - this.radius) this.velocity.x *= -1     // right wall
            else if (this.position.x <= this.radius)/******/ this.velocity.x *= -1     // left wall

            if/***/ (this.position.y >= height - this.radius) this.velocity.y *= -1    // Bottom
            else if (this.position.y <= this.radius)/*******/ this.velocity.y *= -1    // Top
        }
    }
}

function drawLine(p1, p2, clr) {
    ctx.strokeStyle = clr
    ctx.beginPath()
    ctx.moveTo(p1.x, p1.y)
    ctx.lineTo(p2.x, p2.y)
    ctx.stroke()
}

function drawCircle(x, y, r, color) {
    ctx.fillStyle = color
    ctx.lineWidth = 0.5
    ctx.beginPath()
    ctx.arc(x, y, r, 0, 2 * Math.PI)
    ctx.fill()
}

function clearCanvas() {
    ctx.clearRect(0, 0, width, height)
}

const MAX_DISTANCE_FOR_CONNECTION = 200
const MIN_DISTANCE_FOR_MAX_ALPHA = 50
const CANVAS_MIDDLE = V(width / 2, height / 2)

const ctx = canvas.getContext('2d')

const nodes = []

let prevTime = 0
let requestAnimationFrameID
const SINGLE_FRAME_TIME = 5
let dt

createNodes()
startAnimation()

function animate() {
    let now = performance.now()
    dt = now - prevTime
    prevTime = now
    dt = SINGLE_FRAME_TIME

    frame()

    if (!paused) requestAnimationFrameID = requestAnimationFrame(animate)
}

function frame() {
    nodes.forEach(node => {
        node.chkEdgeBounce()
        node.move(dt)
    })
    draw()
}
function draw() {
    clearCanvas()

    if (lines) drawConnections()
    for (let node of nodes)
        node.draw()
}

function drawConnections() {
    nodes.forEach(node1 => {
        nodes.forEach(node2 => {
            if (node1 !== node2)
                drawConnection(node1, node2)
        })
    })
}
function drawConnection(node1, node2) {
    let displacement = node2.position.minus(node1.position)
    let distance = displacement.norm()
    // if (distance >= 300)
    //     return

    const alpha = rescale(MAX_DISTANCE_FOR_CONNECTION, MIN_DISTANCE_FOR_MAX_ALPHA, distance)
    const color = `hsla(180, 90%, 60%, ${alpha})`
    drawLine(node2.position, node1.position, color)

    // if (distance < MIN_DISTANCE_FOR_MAX_ALPHA)
    //     return

    node1.velocity.add(acceleration(node2.mass, displacement))
}

function createNodes() {
    // for (let i = 0; i < noOfNodes; i++) {
    //     nodes.push(createNode({
    //         mass: 1e13,
    //         position: V(0, 0).randomize(lerp(0, width / 2, Math.random())).add(CANVAS_MIDDLE),
    //         velocity: V(0, 0).randomize(lerp(0.05, 0.2, Math.random()))
    //     }))
    // }
    nodes.push(createNode({ mass: 1e13, position: V(800, 700), velocity: V(0, -0.2) }))
    nodes.push(createNode({ mass: 1e13, position: V(1050, 400), velocity: V(0, 0.2) }))
}


function startAnimation() {
    prevTime = performance.now()
    requestAnimationFrameID = requestAnimationFrame(animate)
}
function stopAnimation() {
    cancelAnimationFrame(requestAnimationFrameID)
}
function playNextFrame() {
    prevTime = performance.now() - SINGLE_FRAME_TIME
    animate()
}
function playPrevFrame() {
    // 
}
